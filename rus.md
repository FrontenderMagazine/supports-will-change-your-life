# `@supports` изменит вашу жизнь

Благодаря «прогрессивному улучшению» мы можем использовать много удивительных CSS-свойств, даже если не каждый браузер их поддерживает.

При использовании новых возможностей CSS часто можно просто позволить CSS позаботиться о запасном варианте. CSS всепрощающий, он игнорирует строки кода, которые не понимает. Так браузеры, которые не поддерживают конкретное свойство, просто не будут применять его. Давайте посмотрим на примере.


## CSS Shapes

CSS Shapes (фигуры) это просто и красиво, и их очень легко использовать, если браузер их поддерживает. Можно сделать обтекание текстом круглого изображения, например вот так:

![Скриншот][Обтекание текстом круглого изображения]

Вот CSS. Обратите внимание на свойство `shape-outside`:
    
    .shape {
      width: 20em;
      height: 20em;
      float: left;
      margin: 1em 2em 1em 0;
      border-radius: 25em;
      shape-outside: circle(50%);
    }
 
На прошлой неделе [поддержка браузерами свойства shape-outside][2] составляла 65%, так что она не идеальна, но это не имеет значения. Результат выглядит хорошо и в браузерах, которые не поддерживают свойство `shape-outside`. Мы просто увидим текст, который обтекает изображений по прямой, мы к такому привыкли. 

![Скриншот][Текст обтекает изображение по прямой]

Этот подход позволяет использовать множество новых CSS-свойств, но не все. Как насчет более сложного CSS, который уже не выглядит так хорошо в браузерах, которые его не поддерживают? В качестве примера возьмем режимы наложения:


## Режимы наложения

Когда я в последний раз проверял (на этой неделе), [72% браузеров поддерживали background-blend-modes][4].

CSS может выглядеть следующим образом:
    
    .wrapper {
        background-image: 
        linear-gradient(lightblue 0%, pink 100%), linear-gradient(to right, pink 30%, white 100%), url("https://c7.staticflickr…"); 
        …
        background-blend-mode: hue;
    }

Есть несколько фоновых изображений: одно изображение и два линейных градиента. Затем применяем к ним режим наложения. Вот что можно увидеть в 72% браузеров:

![Фото горы с градиентом и тектом][5]

А вот что вы увидите в браузерах, которые не поддерживают режимы наложения:

![Фото, на котором не видно горы, так как не поддерживаются режимы наложения][6]
  
Видно только градиент, потому что он перекрывает всё остальное, и не смешивается с другими изображениями, как был бы должен. Графическое сообщение, которое несло изображение, утеряно, остается только прочесть текст. Мы, безусловно, не можем использовать такое в продакшене.

Но не спешите убирать режимы наложения! Мы всё же можем использовать его в продакшене. Для этого есть очень мощный инструмент, который может изменить вашу жизнь. Он называется `@supports`.


## @supports

С помощью [@supports][7] можно написать условный оператор, проверяющий, поддерживается ли определенное CSS-свойство браузером; а затем, в зависимости от результата, применить блок кода. Этот оператор также известен как проверка поддержки свойств.

Его использование очень похоже на использование медиавыражений:
    
    @supports (background-blend-mode: hue) {
       /* Этот код выполнится только если браузер поддерживает background-blend-mode: hue */
    }

В первой строке мы пишем `@supports`, а потом  условие. Внутри скобок в первой строке мы говорим, что если `background-blend-mode: hue;` поддерживается, то нужно применить указанные в фигурных скобках правила. Если этот режим наложения не поддерживается, то правила не будут применены.

Вот как `@supports` позволяет использовать режим наложения в продакшене:
    
    .wrapper {
        background-image: url("https://c7.staticflickr…");  
    }

    @supports (background-blend-mode: hue) {
        .wrapper {
            background-image: linear-gradient(lightblue 0%, pink 100%),
            linear-gradient(to right, pink 30%, white 100%), url("https://c7.staticflickr.com/2/1510/…");  
            background-blend-mode: hue;
        }
    }

Стили, применяемые к классу-обертке в верхней части применяются любым браузером. Все они как минимум отобразят фоновое изображение. Стили обертки внутри `@supports` применят только браузеры, которые поддерживают `background-blend-mode: hue;` Вот предыдущий пример в браузерах, которые не поддерживают режимы смешивания. Выглядит **намного** лучше, и определенно можно использовать в продакшене.

![Фото горы с текстом без градиента, если режимы наложения не поддерживаются][8]  


## Поддержка `@supports` браузерами

Здорово, но что насчет поддержки @supports браузерами? [77% браузеров][9] в настоящее время его поддерживают. На данный момент нет поддержки в IE или Opera Mini (в Opera Mini уже есть — _Прим. ред._). Что произойдет, если `@supports` не поддерживается? Тогда он просто не будет выполнять содержащийся в проверке поддержки код, что хорошо.

Рассмотрим наш предыдущий пример. Это то, что мы получаем, когда `@supports` не поддерживается. Точно такие же результаты, как и раньше, потому что он не применяет какой-либо из стилей внутри запроса `@supports`.

![Фото горы с текстом без градиента, если @supports не поддерживаются][10]


## CSS-фигуры и `@supports`

Теперь мы можем улучшить пример использования CSS-фигур, приведенный ранее. Помните, как текст обтекает круглое изображение, когда `shaped-outside` поддерживается? И как текст обтекает по прямой линии скругленное фото?

Теперь мы можем сказать браузеру, что даже если он поддерживает `border-radius`, применять его нужно _только_ тогда, когда свойство `shape-outside` поддерживается.

    .shape{
        width: 20em;
        height: 20em;
        float: left;
        margin: 0.25em 2em 1em 0;
    }

    @supports (shape-outside: circle()) {
        .shape {
            shape-outside: circle(50%);
            border-radius: 25em;
        }    
    }

Таким образом, когда браузер поддерживает свойство `shaped-outside`, вы увидите левое изображение, а когда он не поддерживает — правое. Так-то лучше!

![CSS shapes with supports][11]

С помощью цепочки `or` и `and` можно делать несколько проверок. Если вы хотите быть максимально осторожны, можно добавить еще одно условие, чтобы быть на 100% уверенным, что `border-radius` тоже поддерживается:
    
    .shape{
        width: 20em;
        height: 20em;
        float: left;
        margin: 0.25em 2em 1em 0;
    }

    @supports (border-radius: 25em) and (shape-outside: circle()) {
        .shape {
            shape-outside: circle(50%);
            border-radius: 25em;
        }    
    }

Или, возможно, вы захотите использовать `not`, чтобы стили применились только в том случае, если условие не выполнено:
    
    @supports not (shape-outside: circle()) {
        .shape {
            /* Стили применяться только если shape-outside не поддерживается */
        }    
    }

Традиционно мы использовали [modernizr][12], чтобы определить поддержку свойств браузерами. Это работает, но без JavaScript всё будет ещё лучше. Modernizr может быть и небольшой, но он всё равно должен загрузиться до того, как будут применены правила CSS. И всегда есть некоторый риск, что JavaScript по какой-то причине не выполнится.

Я в восторге от `@supports`. Очень мощный инструмент. Думаю, в будущем при написании CSS мы будем использовать его очень и очень часто.

 
[2]: http://caniuse.com/#search=shape-outside
[4]: http://caniuse.com/#search=background-blend-mode
[7]: https://developer.mozilla.org/en/docs/Web/CSS/@supports
[9]: http://caniuse.com/#search=%40supports
[12]: https://modernizr.com/


[Обтекание текстом круглого изображения]: img/css-shapes-sm.png "Обтекание текстом круглого изображения"
[Текст обтекает изображение по прямой]: img/css-shapes-fallback.png "Текст обтекает изображение по прямой"
[5]: img/blends-working-sm.png
[6]: img/blends-not-supported-sm.png "Blends modes not supported"
[8]: img/blend-modes-supports-small.jpeg
[10]: img/css-shapes-supports-fallback.small.jpeg
[11]: img/shapes-side-by-side-sm.png "CSS shapes with supports"
